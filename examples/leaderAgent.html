<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Block Puzzle Board Editor (UI only)</title>
  <style>
    html,body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#0b0d10;color:#e7ebf0;}
    .wrap{display:grid;grid-template-columns:1fr 600px;gap:16px;padding:16px;}
    canvas{background:#20252b;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.35);}
    .panel{background:#11151a;border:1px solid #243040;border-radius:12px;padding:14px;}
    .panel h2{margin:0 0 10px 0;font-size:16px;color:#bcd;}
    .row{display:flex;gap:8px;align-items:center;margin:8px 0;flex-wrap:wrap;}
    button{background:#1b2330;border:1px solid #2d3b50;color:#e7ebf0;padding:8px 10px;border-radius:8px;cursor:pointer;}
    button:hover{background:#223044;}
    input[type=number]{width:72px;background:#0f141a;color:#dfe6ef;border:1px solid #2a394d;border-radius:8px;padding:6px 8px;}
    textarea{width:100%;height:210px;background:#0f141a;color:#dfe6ef;border:1px solid #2a394d;border-radius:8px;padding:8px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;}
    .small{font-size:12px;color:#9bb;}
    .pill{display:inline-block;padding:2px 6px;border:1px solid #2d3b50;border-radius:999px;font-size:12px;color:#9bb;}
    .hr{height:1px;background:#243040;margin:12px 0;}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="cv" width="820" height="820"></canvas>

    <div class="panel">

      <h2>Leader Action</h2>

      <div class="small">This button will run the leader algorithm on the current board state. For now, it is a stub (no algorithm yet).</div>
      <div class="row">
        <button id="btnRunLeader">Run leader</button>
      </div>
      <div class="row" style="margin-top:8px">
        <label style="display:inline-flex;gap:8px;align-items:center;cursor:pointer">
          <input id="chkShowPaths" type="checkbox" />
          <span class="small">Show paths (D_imm dashed vs D_all solid)</span>
        </label>
      </div>
      <pre id="leaderOut" style="white-space:pre-wrap;background:#0f141a;border:1px solid #2a394d;border-radius:8px;padding:8px;margin:0;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;color:#dfe6ef;max-height:160px;overflow:auto;">No output yet.</pre>

      <div class="hr"></div>

      <h2>Board Editor</h2>
      <div class="small">Drag blocks/slots/obstacles on the board to reposition. Or type coordinates below. Movement rules will be added later.</div>

      <div class="hr"></div>

      <h2>Quick Inputs</h2>
      <div class="row"><span class="pill">Blocks (3×3)</span></div>
      <div class="row">
        <b style="width:54px">Yellow</b>
        x <input id="b_y_x" type="number" min="0" max="17" />
        y <input id="b_y_y" type="number" min="0" max="17" />
      </div>
      <div class="row">
        <b style="width:54px">Red</b>
        x <input id="b_r_x" type="number" min="0" max="17" />
        y <input id="b_r_y" type="number" min="0" max="17" />
      </div>
      <div class="row">
        <b style="width:54px">Blue</b>
        x <input id="b_b_x" type="number" min="0" max="17" />
        y <input id="b_b_y" type="number" min="0" max="17" />
      </div>

      <div class="row" style="margin-top:10px"><span class="pill">Slots (3×3 outlines)</span></div>
      <div class="row">
        <b style="width:54px">Slot0</b>
        x <input id="s0_x" type="number" min="0" max="17" />
        y <input id="s0_y" type="number" min="0" max="17" />
      </div>
      <div class="row">
        <b style="width:54px">Slot1</b>
        x <input id="s1_x" type="number" min="0" max="17" />
        y <input id="s1_y" type="number" min="0" max="17" />
      </div>

      <div class="row" style="margin-top:10px"><span class="pill">Obstacles (2×2)</span></div>
      <div class="small" id="obsHelp">Edit obstacle positions here (or drag on the canvas). Movement legality is not implemented yet.</div>
      <div id="obsList"></div>

      <div class="hr"></div>

      <div class="row">
        <button id="btnApplyInputs">Apply inputs</button>
        <button id="btnReset">Reset</button>
        <button id="btnExport">Export JSON</button>
      </div>

      <div class="hr"></div>

      <!-- <h2>Leader Action</h2>
      <div class="small">This button will run the leader algorithm on the current board state. For now, it is a stub (no algorithm yet).</div>
      <div class="row">
        <button id="btnRunLeader">Run leader</button>
      </div>
      <pre id="leaderOut" style="white-space:pre-wrap;background:#0f141a;border:1px solid #2a394d;border-radius:8px;padding:8px;margin:0;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px;color:#dfe6ef;max-height:160px;overflow:auto;">No output yet.</pre> -->

<h2>State JSON</h2>
      <textarea id="txtState"></textarea>
      <div class="row">
        <button id="btnLoadJSON">Load JSON</button>
        <span class="small" id="lblStatus"></span>
      </div>

      <div class="small" style="margin-top:8px">Walls: the outermost 1-cell border is rendered as dark brown and treated as non-walkable later (for now it is just visual).</div>
    </div>
  </div>

<script>
  // --- Constants (match your existing visual setup) ---
  const GRID = 20;          // board cells: 0..17
  const BLOCK_SIZE = 3;
  const OBS_SIZE = 2;
  const CELL = 40;
  const PADDING = 20;
  const W = PADDING*2 + GRID*CELL;

  const COLORS = {
    yellow: '#f5e85a',
    red:    '#e74c3c',
    blue:   '#4285f4',
    slot:   '#4da3ff',
    obstacle: '#86efac',
    obstacleImmovable: '#3a4048',
    wall:   '#4a2c1a' // dark brown
  };

  const INITIAL = {
    blocks: { blue:{x:12,y:10}, red:{x:9,y:1}, yellow:{x:2,y:10} },
    slots:  { slot0:{x:3,y:4}, slot1:{x:15,y:4} },
    obstacles: {
      obs0: { x: 6, y: 6, id: 'obs0', immovable: true  },
        obs1: { x: 8, y: 4, id: 'obs1', immovable: true},
        obs2: { x: 12, y: 5, id: 'obs2', immovable: true  },
        obs3: { x: 10, y: 7, id: 'obs3', immovable: true},
        obs4: { x: 14, y: 7, id: 'obs4', immovable: false },
        obs5: { x: 3, y: 1, id: 'obs5', immovable: false},
        obs6: { x: 3, y: 7, id: 'obs6', immovable: false },
        obs7: { x: 10, y: 10, id: 'obs7', immovable: false }
    }
  };

  function deepCopy(o){ return JSON.parse(JSON.stringify(o)); }

  // --- Canvas setup ---
  const cv = document.getElementById('cv');
  cv.width = W; cv.height = W;
  const ctx = cv.getContext('2d');

  function tlRect(x,y,sz){
    return { x: PADDING + x*CELL, y: PADDING + y*CELL, w: sz*CELL, h: sz*CELL };
  }

  function drawGrid(){
    ctx.clearRect(0,0,W,W);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,W,W);

    // Walls: outermost 1-cell radius
    ctx.fillStyle = COLORS.wall;
    for (let x=0; x<GRID; x++){
      // top row
      ctx.fillRect(PADDING + x*CELL, PADDING + 0*CELL, CELL, CELL);
      // bottom row
      ctx.fillRect(PADDING + x*CELL, PADDING + (GRID-1)*CELL, CELL, CELL);
    }
    for (let y=0; y<GRID; y++){
      // left col
      ctx.fillRect(PADDING + 0*CELL, PADDING + y*CELL, CELL, CELL);
      // right col
      ctx.fillRect(PADDING + (GRID-1)*CELL, PADDING + y*CELL, CELL, CELL);
    }

    // Grid lines
    ctx.strokeStyle = '#2d3642';
    ctx.lineWidth = 1;
    for (let i=0;i<=GRID;i++){
      ctx.beginPath();
      ctx.moveTo(PADDING+i*CELL, PADDING);
      ctx.lineTo(PADDING+i*CELL, PADDING+GRID*CELL);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(PADDING, PADDING+i*CELL);
      ctx.lineTo(PADDING+GRID*CELL, PADDING+i*CELL);
      ctx.stroke();
    }
  }

  function drawSlot(s){
    const r = tlRect(s.x, s.y, BLOCK_SIZE);
    ctx.lineWidth = 6;
    ctx.strokeStyle = COLORS.slot;
    ctx.strokeRect(r.x+2, r.y+2, r.w-4, r.h-4);
  }

  function hatchRect(r){
    ctx.save();
    ctx.beginPath();
    ctx.rect(r.x, r.y, r.w, r.h);
    ctx.clip();
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    for (let x=r.x-r.h; x<r.x+r.w; x+=8){
      ctx.beginPath();
      ctx.moveTo(x, r.y);
      ctx.lineTo(x+r.h, r.y+r.h);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawObstacle(ob){
    const r = tlRect(ob.x, ob.y, OBS_SIZE);
    ctx.fillStyle = ob.immovable ? COLORS.obstacleImmovable : COLORS.obstacle;
    ctx.fillRect(r.x+2, r.y+2, r.w-4, r.h-4);
    if (ob.immovable) hatchRect({x:r.x+2,y:r.y+2,w:r.w-4,h:r.h-4});

    ctx.fillStyle = '#0d1320';
    ctx.font = '700 12px ui-monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(ob.id, r.x+r.w/2, r.y+r.h/2);
  }

  function drawBlock(name, pos){
    const r = tlRect(pos.x, pos.y, BLOCK_SIZE);
    ctx.fillStyle = COLORS[name] || '#888';
    ctx.fillRect(r.x+2, r.y+2, r.w-4, r.h-4);
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#1d2430';
    ctx.strokeRect(r.x+1.5, r.y+1.5, r.w-3, r.h-3);

    ctx.fillStyle = '#0d1320';
    ctx.font = '700 18px ui-monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const digit = name==='yellow' ? '1' : name==='red' ? '2' : '3';
    ctx.fillText(digit, r.x+r.w/2, r.y+r.h/2);
  }

  function tlCenterPx(tl){
    // TL coords -> pixel center of the 3x3 block footprint
    const cx = PADDING + (tl.x + BLOCK_SIZE/2) * CELL;
    const cy = PADDING + (tl.y + BLOCK_SIZE/2) * CELL;
    return {cx, cy};
  }

  function drawPathPolyline(path, strokeStyle, lineWidth, dashed){
    if (!path || path.length < 2) return;
    ctx.save();
    ctx.strokeStyle = strokeStyle;
    ctx.lineWidth = lineWidth;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    if (dashed) ctx.setLineDash([10, 8]);
    ctx.beginPath();
    for (let i=0; i<path.length; i++){
      const {cx, cy} = tlCenterPx(path[i]);
      if (i===0) ctx.moveTo(cx, cy);
      else ctx.lineTo(cx, cy);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawPathOverlay(){
    if (!PATH_OVERLAY || !PATH_OVERLAY.enabled) return;

    // D_imm: dashed (white)
    for (const [bn, path] of Object.entries(PATH_OVERLAY.imm || {})){
      drawPathPolyline(path, 'rgba(255,165,0,0.95)', 4, true);
    }

    // D_all: solid (blue)
    for (const [bn, path] of Object.entries(PATH_OVERLAY.all || {})){
      drawPathPolyline(path, 'rgba(77,163,255,0.9)', 3, false);
    }
  }


  function render(state){
    drawGrid();
    for (const s of Object.values(state.slots)) drawSlot(s);
    for (const o of Object.values(state.obstacles)) drawObstacle(o);
    for (const [name,pos] of Object.entries(state.blocks)) drawBlock(name, pos);

    drawPathOverlay();
  }

  // --- UI state ---
  let S = deepCopy(INITIAL);


  // --- Path overlay state (for visualizing shortest-path routes) ---
  let PATH_OVERLAY = {
    enabled: false,
    imm: {}, // { blockName: [{x,y}, ...] } using TL (top-left) coordinates
    all: {}  // { blockName: [{x,y}, ...] } using TL (top-left) coordinates
  };

  const chkShowPaths = document.getElementById('chkShowPaths');
  if (chkShowPaths){
    chkShowPaths.addEventListener('change', (e)=>{
      PATH_OVERLAY.enabled = !!e.target.checked;
      if (PATH_OVERLAY.enabled){
        // Recompute paths immediately so the toggle has an effect without needing to press Run leader.
        runLeaderDiagnostic();
      } else {
        PATH_OVERLAY.imm = {};
        PATH_OVERLAY.all = {};
        render(S);
      }
    });
  }

  function setStatus(msg){
    document.getElementById('lblStatus').textContent = msg;
  }

  
  function sortedObstacleKeys(){
    return Object.keys(S.obstacles || {}).sort((a,b)=>{
      const na = parseInt(String(a).replace(/\D+/g,'')) || 0;
      const nb = parseInt(String(b).replace(/\D+/g,'')) || 0;
      if (na!==nb) return na-nb;
      return String(a).localeCompare(String(b));
    });
  }

  function renderObstacleInputs(){
    const wrap = document.getElementById('obsList');
    if (!wrap) return;
    wrap.innerHTML = '';
    const keys = sortedObstacleKeys();
    if (keys.length===0){
      const div = document.createElement('div');
      div.className = 'small';
      div.textContent = 'No obstacles in state.';
      wrap.appendChild(div);
      return;
    }
    for (const k of keys){
      const o = S.obstacles[k];
      const row = document.createElement('div');
      row.className = 'row';
      row.style.alignItems = 'center';

      const label = document.createElement('b');
      label.style.width = '54px';
      label.textContent = k;
      row.appendChild(label);

      row.appendChild(document.createTextNode('x '));
      const ix = document.createElement('input');
      ix.type = 'number'; ix.min = '0'; ix.max = String(GRID-1);
      ix.id = `obs_${k}_x`;
      ix.value = o.x;
      row.appendChild(ix);

      row.appendChild(document.createTextNode(' y '));
      const iy = document.createElement('input');
      iy.type = 'number'; iy.min = '0'; iy.max = String(GRID-1);
      iy.id = `obs_${k}_y`;
      iy.value = o.y;
      row.appendChild(iy);

      const immWrap = document.createElement('label');
      immWrap.style.marginLeft = '10px';
      immWrap.style.display = 'inline-flex';
      immWrap.style.gap = '6px';
      immWrap.style.alignItems = 'center';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.id = `obs_${k}_imm`;
      cb.checked = !!o.immovable;
      immWrap.appendChild(cb);

      const txt = document.createElement('span');
      txt.className = 'small';
      txt.textContent = 'immovable';
      immWrap.appendChild(txt);

      row.appendChild(immWrap);

      wrap.appendChild(row);
    }
  }

function syncInputsFromState(){
    document.getElementById('b_y_x').value = S.blocks.yellow.x;
    document.getElementById('b_y_y').value = S.blocks.yellow.y;
    document.getElementById('b_r_x').value = S.blocks.red.x;
    document.getElementById('b_r_y').value = S.blocks.red.y;
    document.getElementById('b_b_x').value = S.blocks.blue.x;
    document.getElementById('b_b_y').value = S.blocks.blue.y;

    document.getElementById('s0_x').value = S.slots.slot0.x;
    document.getElementById('s0_y').value = S.slots.slot0.y;
    document.getElementById('s1_x').value = S.slots.slot1.x;
    document.getElementById('s1_y').value = S.slots.slot1.y;

    renderObstacleInputs();

    document.getElementById('txtState').value = JSON.stringify(S, null, 2);
  }

  function applyInputsToState(){
    const clamp = (v)=>Math.max(0, Math.min(GRID-1, v|0));

    S.blocks.yellow.x = clamp(+document.getElementById('b_y_x').value);
    S.blocks.yellow.y = clamp(+document.getElementById('b_y_y').value);
    S.blocks.red.x    = clamp(+document.getElementById('b_r_x').value);
    S.blocks.red.y    = clamp(+document.getElementById('b_r_y').value);
    S.blocks.blue.x   = clamp(+document.getElementById('b_b_x').value);
    S.blocks.blue.y   = clamp(+document.getElementById('b_b_y').value);

    S.slots.slot0.x = clamp(+document.getElementById('s0_x').value);
    S.slots.slot0.y = clamp(+document.getElementById('s0_y').value);
    S.slots.slot1.x = clamp(+document.getElementById('s1_x').value);
    S.slots.slot1.y = clamp(+document.getElementById('s1_y').value);

    document.getElementById('txtState').value = JSON.stringify(S, null, 2);
    
    // Obstacles (2x2)
    for (const k of sortedObstacleKeys()){
      const ox = document.getElementById(`obs_${k}_x`);
      const oy = document.getElementById(`obs_${k}_y`);
      const oc = document.getElementById(`obs_${k}_imm`);
      if (!ox || !oy) continue;
      S.obstacles[k].x = clamp(+ox.value);
      S.obstacles[k].y = clamp(+oy.value);
      if (oc) S.obstacles[k].immovable = !!oc.checked;
    }

render(S);
    setStatus('Applied inputs.');
  }

  // --- Dragging ---
  function mouseToCell(evt){
    const r = cv.getBoundingClientRect();
    const mx = evt.clientX - r.left;
    const my = evt.clientY - r.top;
    const x = (mx - PADDING) / CELL;
    const y = (my - PADDING) / CELL;
    return { x, y, mx, my };
  }

  function hitTest(state, cellX, cellY){
    const hits = [];
    // blocks
    for (const [name,p] of Object.entries(state.blocks)){
      if (cellX >= p.x && cellX < p.x + BLOCK_SIZE && cellY >= p.y && cellY < p.y + BLOCK_SIZE){
        hits.push({type:'block', id:name, size:BLOCK_SIZE, x:p.x, y:p.y});
      }
    }
    // slots
    for (const [sid,s] of Object.entries(state.slots)){
      if (cellX >= s.x && cellX < s.x + BLOCK_SIZE && cellY >= s.y && cellY < s.y + BLOCK_SIZE){
        hits.push({type:'slot', id:sid, size:BLOCK_SIZE, x:s.x, y:s.y});
      }
    }
    // obstacles
    for (const [oid,o] of Object.entries(state.obstacles)){
      if (cellX >= o.x && cellX < o.x + OBS_SIZE && cellY >= o.y && cellY < o.y + OBS_SIZE){
        hits.push({type:'obstacle', id:oid, size:OBS_SIZE, x:o.x, y:o.y});
      }
    }
    // prefer smaller (obstacle) and later draws (blocks above)
    hits.sort((a,b)=>a.size-b.size);
    return hits[hits.length-1] || null;
  }

  let drag = null;

  cv.addEventListener('mousedown', (evt)=>{
    const m = mouseToCell(evt);
    const cellX = Math.floor(m.x);
    const cellY = Math.floor(m.y);
    const h = hitTest(S, cellX, cellY);
    if (!h) return;

    drag = {
      type: h.type,
      id: h.id,
      size: h.size,
      offX: m.x - h.x,
      offY: m.y - h.y
    };
  });

  window.addEventListener('mousemove', (evt)=>{
    if (!drag) return;
    const m = mouseToCell(evt);
    const nx = Math.round(m.x - drag.offX);
    const ny = Math.round(m.y - drag.offY);

    const clampedX = Math.max(0, Math.min(GRID-1, nx));
    const clampedY = Math.max(0, Math.min(GRID-1, ny));

    if (drag.type==='block'){
      S.blocks[drag.id].x = clampedX;
      S.blocks[drag.id].y = clampedY;
    } else if (drag.type==='slot'){
      S.slots[drag.id].x = clampedX;
      S.slots[drag.id].y = clampedY;
    } else {
      S.obstacles[drag.id].x = clampedX;
      S.obstacles[drag.id].y = clampedY;
    }
    render(S);
  });

  window.addEventListener('mouseup', ()=>{
    if (!drag) return;
    drag = null;
    syncInputsFromState();
    setStatus('Dragged and updated JSON.');
  });

  // --- Buttons ---
  document.getElementById('btnApplyInputs').onclick = applyInputsToState;
  document.getElementById('btnReset').onclick = ()=>{
    S = deepCopy(INITIAL);
    syncInputsFromState();
    render(S);
    setStatus('Reset.');
  };
  document.getElementById('btnExport').onclick = ()=>{
    document.getElementById('txtState').value = JSON.stringify(S, null, 2);
    document.getElementById('txtState').select();
    document.execCommand('copy');
    setStatus('Copied JSON to clipboard.');
  };
  document.getElementById('btnLoadJSON').onclick = ()=>{
    try{
      const txt = document.getElementById('txtState').value;
      const parsed = JSON.parse(txt);
      // minimal validation
      if (!parsed.blocks || !parsed.slots || !parsed.obstacles) throw new Error('JSON must contain blocks, slots, obstacles');
      S = parsed;
      syncInputsFromState();
      render(S);
      setStatus('Loaded JSON.');
    }catch(e){
      setStatus('JSON error: ' + e.message);
    }
  };


  // --- Leader diagnostic (no action selection yet) ---
// Computes whether movable obstacles are currently affecting shortest paths from blocks to slots.
// Outputs: needs_obstacle_clearing + affected blocks, plus optional obstacle attribution.

function runLeaderDiagnostic(){
  const snapshot = JSON.parse(JSON.stringify(S));

  // ----- Walls -----
  // Current UI renders an outer wall ring (row/col 0 and GRID-1). We treat it as blocked cells here.
  // If you later add internal walls, store them as snapshot.walls = [{x,y}, ...] and they will be included.
  const wallSet = new Set();
  for (let x=0; x<GRID; x++){
    wallSet.add(`${x},0`);
    wallSet.add(`${x},${GRID-1}`);
  }
  for (let y=0; y<GRID; y++){
    wallSet.add(`0,${y}`);
    wallSet.add(`${GRID-1},${y}`);
  }
  if (Array.isArray(snapshot.walls)){
    for (const w of snapshot.walls){
      if (w && Number.isFinite(w.x) && Number.isFinite(w.y)){
        wallSet.add(`${w.x|0},${w.y|0}`);
      }
    }
  }

  // ----- Helpers -----
  const inBoundsTL = (x,y,sz)=> (x>=0 && y>=0 && (x+sz)<=GRID && (y+sz)<=GRID);

  const rectOverlap = (ax,ay,asz, bx,by,bsz)=>
    (ax < bx + bsz && bx < ax + asz && ay < by + bsz && by < ay + asz);

  const footprintHitsWalls = (tlx,tly,sz)=>{
    for (let dy=0; dy<sz; dy++){
      for (let dx=0; dx<sz; dx++){
        if (wallSet.has(`${tlx+dx},${tly+dy}`)) return true;
      }
    }
    return false;
  };

  const obstaclesArr = Object.values(snapshot.obstacles || {});
  const immObs = obstaclesArr.filter(o=>!!o.immovable);
  const movObs = obstaclesArr.filter(o=>!o.immovable);

  const slotsArr = Object.values(snapshot.slots || {});

  // Lock blocks already in a slot (TL matches slot TL)
  function isBlockInAnySlotTL(b){
    const bx = b.x|0, by = b.y|0;
    for (const sl of slotsArr){
      if ((sl.x|0) === bx && (sl.y|0) === by) return true;
    }
    return false;
  }
  for (const [bn,b] of Object.entries(snapshot.blocks || {})){
    if (b && isBlockInAnySlotTL(b)){
      b.locked = true;
      if (S.blocks?.[bn]) S.blocks[bn].locked = true; // persist in editor state
    }
  }

  // TL lattice for 3x3 blocks
  const TL_W = GRID - BLOCK_SIZE + 1;
  const TL_H = GRID - BLOCK_SIZE + 1;
  const INF = 1e9;

  function okBlockTL(x,y, includeMovables){
    if (!inBoundsTL(x,y,BLOCK_SIZE)) return false;
    if (footprintHitsWalls(x,y,BLOCK_SIZE)) return false;
    for (const o of immObs){
      if (rectOverlap(x,y,BLOCK_SIZE, o.x,o.y,OBS_SIZE)) return false;
    }
    if (includeMovables){
      for (const o of movObs){
        if (rectOverlap(x,y,BLOCK_SIZE, o.x,o.y,OBS_SIZE)) return false;
      }
    }
    return true;
  }

  // Multi-source BFS from slot TLs
  function bfs(includeMovables){
    const dist = Array.from({length: TL_H}, ()=>Array(TL_W).fill(INF));
    const qx = new Array(TL_W*TL_H);
    const qy = new Array(TL_W*TL_H);
    let head=0, tail=0;

    for (const sl of slotsArr){
      const sx = sl.x|0, sy = sl.y|0;
      if (sx<0 || sy<0 || sx>=TL_W || sy>=TL_H) continue;
      if (!okBlockTL(sx,sy, includeMovables)) continue;
      if (dist[sy][sx] !== 0){
        dist[sy][sx] = 0;
        qx[tail]=sx; qy[tail]=sy; tail++;
      }
    }

    const DX=[0,0,-1,1], DY=[-1,1,0,0];
    while (head<tail){
      const x=qx[head], y=qy[head]; head++;
      const nd = dist[y][x] + 1;
      for (let k=0;k<4;k++){
        const nx=x+DX[k], ny=y+DY[k];
        if (nx<0 || ny<0 || nx>=TL_W || ny>=TL_H) continue;
        if (!okBlockTL(nx,ny, includeMovables)) continue;
        if (dist[ny][nx] <= nd) continue;
        dist[ny][nx] = nd;
        qx[tail]=nx; qy[tail]=ny; tail++;
      }
    }
    return dist;
  }

  const D_imm = bfs(false);
  const D_all = bfs(true);

  function getDist(D, x,y){
    if (x<0 || y<0 || x>=TL_W || y>=TL_H) return INF;
    return D[y][x];
  }

  // Reconstruct one downhill path on a given distance field (for visualization)
  function reconstructDownhillPath(D, startTL){
    const bx = startTL.x|0, by = startTL.y|0;
    let d = getDist(D, bx, by);
    if (d >= INF) return [];

    const path = [{x:bx, y:by}];
    const DX=[0,0,-1,1], DY=[-1,1,0,0];
    let cx=bx, cy=by;
    let guard=0;

    while (d>0 && guard++ < 512){
      let stepped = false;
      for (let k=0;k<4;k++){
        const nx=cx+DX[k], ny=cy+DY[k];
        if (nx<0 || ny<0 || nx>=TL_W || ny>=TL_H) continue;
        if (getDist(D, nx, ny) === d-1){
          cx=nx; cy=ny; d=d-1;
          path.push({x:cx,y:cy});
          stepped = true;
          break;
        }
      }
      if (!stepped) break;
    }
    return path;
  }

  // Update overlay paths (regardless of whether we will move an obstacle or a block)
  PATH_OVERLAY.imm = {};
  PATH_OVERLAY.all = {};
  for (const [bn, b] of Object.entries(snapshot.blocks || {})){
    if (b && b.locked) continue;
    PATH_OVERLAY.imm[bn] = reconstructDownhillPath(D_imm, {x:b.x|0, y:b.y|0});
    PATH_OVERLAY.all[bn] = reconstructDownhillPath(D_all, {x:b.x|0, y:b.y|0});
  }

  // ----- Determine whether any block is obstacle-blocked or detoured by movable obstacles -----
  const affected = [];
  const perBlock = [];

  for (const [name,b] of Object.entries(snapshot.blocks || {})){
    const bx = b.x|0, by = b.y|0;
    const di = getDist(D_imm, bx, by);
    const da = getDist(D_all, bx, by);

    let status = "ok";
    if (b.locked){
      status = "in_slot_locked";
    } else if (da>=INF && di<INF) status = "blocked_by_movable";
    else if (da>di) status = "detour_due_to_movable";
    else if (di>=INF && da>=INF) status = "unreachable_even_ignoring_movable";

    const entry = { block:name, TL:{x:bx,y:by}, D_imm:di>=INF?null:di, D_all:da>=INF?null:da, status };

    if (!b.locked && (status==="blocked_by_movable" || status==="detour_due_to_movable")){
      affected.push(entry);
    }
    perBlock.push(entry);
  }

  const needsObstacleClearing = affected.length>0;

  // ---------------- Obstacle move suggestion (bounded <= 2 moves) ----------------
  const DIRS_OBS = [
    {name:'up',dx:0,dy:-1},
    {name:'down',dx:0,dy:1},
    {name:'left',dx:-1,dy:0},
    {name:'right',dx:1,dy:0},
  ];

  function isObstacleMoveLegal(state, obsKey, dir){
    const o = state.obstacles?.[obsKey];
    if (!o) return {ok:false, reason:`Missing obstacle ${obsKey}`};
    if (o.immovable) return {ok:false, reason:`${obsKey} is immovable`};

    const nx = (o.x|0) + dir.dx;
    const ny = (o.y|0) + dir.dy;
    if (!inBoundsTL(nx, ny, OBS_SIZE)) return {ok:false, reason:'Out of bounds'};
    if (footprintHitsWalls(nx, ny, OBS_SIZE)) return {ok:false, reason:'Hits wall'};

    // collide with other obstacles
    for (const [k2,o2] of Object.entries(state.obstacles || {})){
      if (k2 === obsKey) continue;
      if (rectOverlap(nx,ny,OBS_SIZE, o2.x|0,o2.y|0,OBS_SIZE)) return {ok:false, reason:`Hits obstacle ${k2}`};
    }
    // collide with blocks (ignore locked blocks)
    for (const [bn,b] of Object.entries(state.blocks || {})){
      if (b && b.locked) continue;
      if (rectOverlap(nx,ny,OBS_SIZE, b.x|0,b.y|0,BLOCK_SIZE)) return {ok:false, reason:`Hits block ${bn}`};
    }
    return {ok:true, reason:'OK'};
  }

  function applyObstacleMove(state, obsKey, dir){
    const t = JSON.parse(JSON.stringify(state));
    t.obstacles[obsKey].x = (t.obstacles[obsKey].x|0) + dir.dx;
    t.obstacles[obsKey].y = (t.obstacles[obsKey].y|0) + dir.dy;
    return t;
  }

  function computeDAllFor(stateX){
    const obsArr = Object.values(stateX.obstacles || {});
    const immX = obsArr.filter(o=>!!o.immovable);
    const movX = obsArr.filter(o=>!o.immovable);

    function okTL_X(x,y){
      if (!inBoundsTL(x,y,BLOCK_SIZE)) return false;
      if (footprintHitsWalls(x,y,BLOCK_SIZE)) return false;
      for (const o of immX){
        if (rectOverlap(x,y,BLOCK_SIZE, o.x|0,o.y|0,OBS_SIZE)) return false;
      }
      for (const o of movX){
        if (rectOverlap(x,y,BLOCK_SIZE, o.x|0,o.y|0,OBS_SIZE)) return false;
      }
      return true;
    }

    const dist = Array.from({length: TL_H}, ()=>Array(TL_W).fill(INF));
    const qx = new Array(TL_W*TL_H);
    const qy = new Array(TL_W*TL_H);
    let head=0, tail=0;

    for (const sl of Object.values(stateX.slots || {})){
      const sx = sl.x|0, sy = sl.y|0;
      if (sx<0 || sy<0 || sx>=TL_W || sy>=TL_H) continue;
      if (!okTL_X(sx,sy)) continue;
      if (dist[sy][sx] !== 0){
        dist[sy][sx] = 0;
        qx[tail]=sx; qy[tail]=sy; tail++;
      }
    }

    const DX=[0,0,-1,1], DY=[-1,1,0,0];
    while (head<tail){
      const x=qx[head], y=qy[head]; head++;
      const nd = dist[y][x] + 1;
      for (let k=0;k<4;k++){
        const nx=x+DX[k], ny=y+DY[k];
        if (nx<0 || ny<0 || nx>=TL_W || ny>=TL_H) continue;
        if (!okTL_X(nx,ny)) continue;
        if (dist[ny][nx] <= nd) continue;
        dist[ny][nx] = nd;
        qx[tail]=nx; qy[tail]=ny; tail++;
      }
    }
    return dist;
  }

  function scoreStateAgainstBaseline(stateX, baselineDAll, blocksToScore){
    const D = computeDAllFor(stateX);
    const INF_WIN = 1000;
    let score = 0;
    const per = {};

    for (const bn of blocksToScore){
      const b = stateX.blocks?.[bn];
      if (!b || b.locked) continue;
      const before = getDist(baselineDAll, b.x|0, b.y|0);
      const after  = getDist(D,             b.x|0, b.y|0);

      let imp = 0;
      if (before>=INF && after<INF) imp = INF_WIN;
      else if (before<INF && after<INF) imp = Math.max(0, before-after);
      else imp = 0;

      score += imp;
      per[bn] = { before: (before>=INF? null: before), after: (after>=INF? null: after), improvement: imp };
    }
    return { score, perBlock: per };
  }

  function suggestObstaclePlan(affectedEntries){
    const movableKeys = Object.entries(snapshot.obstacles || {})
      .filter(([k,o])=>!o.immovable)
      .map(([k,o])=>({key:k, id:o.id ?? k}));

    const blocksToScore = affectedEntries.map(e=>e.block);
    const baseline = D_all;

    let best = null;

    // 1-step
    for (const ok of movableKeys.map(o=>o.key)){
      for (const d1 of DIRS_OBS){
        const c1 = isObstacleMoveLegal(snapshot, ok, d1);
        if (!c1.ok) continue;
        const s1 = applyObstacleMove(snapshot, ok, d1);
        const r1 = scoreStateAgainstBaseline(s1, baseline, blocksToScore);
        const cand = { obstacle: ok, steps:[d1.name], score:r1.score, perBlock:r1.perBlock };
        if (!best || cand.score > best.score) best = cand;
      }
    }

    // 2-step (same obstacle, at most twice)
    for (const ok of movableKeys.map(o=>o.key)){
      for (const d1 of DIRS_OBS){
        const c1 = isObstacleMoveLegal(snapshot, ok, d1);
        if (!c1.ok) continue;
        const s1 = applyObstacleMove(snapshot, ok, d1);
        for (const d2 of DIRS_OBS){
          const c2 = isObstacleMoveLegal(s1, ok, d2);
          if (!c2.ok) continue;
          const s2 = applyObstacleMove(s1, ok, d2);
          const r2 = scoreStateAgainstBaseline(s2, baseline, blocksToScore);
          const cand = { obstacle: ok, steps:[d1.name, d2.name], score:r2.score, perBlock:r2.perBlock };
          if (!best || cand.score > best.score) best = cand;
        }
      }
    }

    return best;
  }

  // ---------------- Block move selection helpers (only used when no obstacle to clear) ----------------
  const DIRS_BLOCK = [
    {name:"UP", dx:0, dy:-1},
    {name:"DOWN", dx:0, dy:1},
    {name:"LEFT", dx:-1, dy:0},
    {name:"RIGHT", dx:1, dy:0},
  ];
  function canPlaceBlockAt(x,y,selfName){
    if (!inBoundsTL(x,y,BLOCK_SIZE)) return false;
    if (footprintHitsWalls(x,y,BLOCK_SIZE)) return false;

    for (const o of immObs){
      if (rectOverlap(x,y,BLOCK_SIZE, o.x|0,o.y|0,OBS_SIZE)) return false;
    }
    for (const o of movObs){
      if (rectOverlap(x,y,BLOCK_SIZE, o.x|0,o.y|0,OBS_SIZE)) return false;
    }

    for (const [bn,b] of Object.entries(snapshot.blocks || {})){
      if (bn === selfName) continue;
      if (b && b.locked) continue;
      if (rectOverlap(x,y,BLOCK_SIZE, b.x|0,b.y|0,BLOCK_SIZE)) return false;
    }
    return true;
  }

  function okBlockTL_withBlocks(x,y, selfName){
    if (!inBoundsTL(x,y,BLOCK_SIZE)) return false;
    if (footprintHitsWalls(x,y,BLOCK_SIZE)) return false;
    for (const o of immObs){
      if (rectOverlap(x,y,BLOCK_SIZE, o.x|0,o.y|0,OBS_SIZE)) return false;
    }
    // treat other blocks as obstacles (ignore locked blocks)
    for (const [bn,b] of Object.entries(snapshot.blocks || {})){
      if (bn === selfName) continue;
      if (b && b.locked) continue;
      if (rectOverlap(x,y,BLOCK_SIZE, b.x|0,b.y|0,BLOCK_SIZE)) return false;
    }
    return true;
  }

  function bfsImmWithBlocks(selfName){
    const dist = Array.from({length: TL_H}, ()=>Array(TL_W).fill(INF));
    const qx = new Array(TL_W*TL_H);
    const qy = new Array(TL_W*TL_H);
    let head=0, tail=0;

    for (const sl of slotsArr){
      const sx = sl.x|0, sy = sl.y|0;
      if (sx<0 || sy<0 || sx>=TL_W || sy>=TL_H) continue;
      if (!okBlockTL_withBlocks(sx,sy, selfName)) continue;
      dist[sy][sx] = 0;
      qx[tail]=sx; qy[tail]=sy; tail++;
    }

    const DX=[0,0,-1,1], DY=[-1,1,0,0];
    while (head<tail){
      const x=qx[head], y=qy[head]; head++;
      const nd = dist[y][x] + 1;
      for (let k=0;k<4;k++){
        const nx=x+DX[k], ny=y+DY[k];
        if (nx<0 || ny<0 || nx>=TL_W || ny>=TL_H) continue;
        if (!okBlockTL_withBlocks(nx,ny, selfName)) continue;
        if (dist[ny][nx] <= nd) continue;
        dist[ny][nx] = nd;
        qx[tail]=nx; qy[tail]=ny; tail++;
      }
    }
    return dist;
  }

  // ----- Compose output -----
  const lines = [];
  lines.push("Leader diagnostic (one-step policy).");
  lines.push(`needs_obstacle_clearing: ${needsObstacleClearing ? "YES" : "NO"}`);
  lines.push("");

  lines.push("Per-block distances (steps on TL grid):");
  for (const e of perBlock){
    const di = (e.D_imm===null ? "INF" : e.D_imm);
    const da = (e.D_all===null ? "INF" : e.D_all);
    lines.push(`- ${e.block}: D_imm=${di}, D_all=${da}  => ${e.status}`);
  }

  if (needsObstacleClearing){
    lines.push("");
    lines.push("Obstacle handling plan (bounded <=2 moves; heuristic):");
    const plan = suggestObstaclePlan(affected);
    if (!plan || plan.score <= 0){
      lines.push("- No beneficial 1–2 step obstacle move found under the current scoring.");
      lines.push("- Chosen step: (none)");
    } else {
      lines.push(`- Planned path: move ${plan.obstacle} ${plan.steps.join(" then ")}`);
      lines.push(`- Chosen first step: move ${plan.obstacle} ${plan.steps[0]}`);
      lines.push("- Expected distances for affected blocks (D_all):");
      for (const [bn,info] of Object.entries(plan.perBlock)){
        const b0 = (info.before===null ? "INF" : info.before);
        const b1 = (info.after===null ? "INF" : info.after);
        lines.push(`  • ${bn}: ${b0} → ${b1} (improvement=${info.improvement})`);
      }
    }
  } else {
    // Only consider block moves if there is no obstacle to clear.
    // Eligibility: (1) not locked/in slot, (2) not blocked by other blocks relative to D_imm,
    // then take the first downhill move under D_all. Priority order: blue -> red -> yellow.
    function chooseDownhillStepWithBlockGate(blockName){
      const b = snapshot.blocks?.[blockName];
      if (!b || b.locked) return {block:blockName, ok:false, reason:"locked/in slot"};

      const x = b.x|0, y = b.y|0;

      // Since needsObstacleClearing is false globally, di==da for all movable blocks, but we keep this explicit.
      const di0 = getDist(D_imm, x, y);
      const da0 = getDist(D_all, x, y);
      const obstacleBlocked = (di0 < INF && (da0 >= INF || da0 > di0));
      if (obstacleBlocked){
        return {block:blockName, ok:false, reason:`obstacle-blocked (D_imm ${di0>=INF?'INF':di0} vs D_all ${da0>=INF?'INF':da0})`};
      }

      const D_imm_blocks = bfsImmWithBlocks(blockName);
      const dib0 = getDist(D_imm_blocks, x, y);
      const blockedByOtherBlocks =
        (di0 < INF && dib0 >= INF) || (di0 < INF && dib0 > di0);

      if (blockedByOtherBlocks){
        return {block:blockName, ok:false, reason:`blocked by other blocks (D_imm ${di0>=INF?'INF':di0} vs D_imm+blocks ${dib0>=INF?'INF':dib0})`};
      }

      // Now pick a downhill step under D_all that is currently legal.
      for (const d of DIRS_BLOCK){
        const nx = x + d.dx, ny = y + d.dy;
        const d1 = getDist(D_all, nx, ny);
        if (d1 >= da0) continue;
        if (!canPlaceBlockAt(nx, ny, blockName)) continue;
        return {block:blockName, ok:true, step:d.name, from:{x,y}, to:{x:nx,y:ny}, d0:da0, d1};
      }
      return {block:blockName, ok:false, reason:"no downhill legal move"};
    }

    const order = ["blue","red","yellow"];
    let pick = null;
    const notes = [];

    for (const bn of order){
      const r = chooseDownhillStepWithBlockGate(bn);
      if (r.ok && !pick){
        pick = r;
      } else if (!r.ok){
        notes.push(`- ${bn}: skipped (${r.reason})`);
      }
    }

    lines.push("");
    lines.push("Block-move policy (only when no obstacle to clear):");
    lines.push("- Priority order: blue → red → yellow");
    if (!pick){
      lines.push("- Chosen step: (none)  [No eligible downhill move found]");
      if (notes.length){
        lines.push("");
        lines.push("Why blocks were skipped:");
        lines.push(...notes);
      }
    } else {
      lines.push(`- Chosen step: move ${pick.block} ${pick.step}  (D_all ${pick.d0} → ${pick.d1})`);
      lines.push(`- From TL=(${pick.from.x},${pick.from.y}) to TL=(${pick.to.x},${pick.to.y})`);
      if (notes.length){
        lines.push("");
        lines.push("Other blocks skipped:");
        lines.push(...notes);
      }
    }
  }

  document.getElementById('leaderOut').textContent = lines.join("\n");
  setStatus('Leader diagnostic executed.');

  // Re-render so path overlays update immediately
  render(S);
}
document.getElementById('btnRunLeader').onclick = runLeaderDiagnostic;


  // --- Init ---
  syncInputsFromState();
  render(S);
  setStatus('Ready.');
</script>
</body>
</html>
